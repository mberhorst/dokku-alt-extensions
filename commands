#!/usr/bin/env bash
set -eo pipefail; [[ $DOKKU_TRACE ]] && set -x

# Check if name is specified
if [[ $1 == nvcc ]] || [[ $1 == nvcc:* ]]; then

  if [[ -z $2 ]]; then
    echo "You must specify an app name"
    exit 1
  else
    APP="$2"

    # Check if app exists with the same name
    if [ ! -d "$DOKKU_ROOT/$APP" ]; then
      echo "App $APP does not exist"
      exit 1
    fi

  fi
fi

case "$1" in

  # helper to backup a data volume; specifically everything inside "/app" (as *CONVENTION*)
  # So, if you create a volume using "volume:create notes_volume /app/var", it gets *backed up*.
  # If you create a volume using "volume:create notes_volume /var", it does NOT get *backed up*.
  # Furthermore, 2 special files are included in the backup:
  # .paths -- the paths with which the volume was created
  # .app-links -- the current connections to the apps
  #
  # HOW TO USE:
  # either: volume:backup | base64 -D > /your/local/backup.tar
  # or: volume:backup /path/on/server.tar
  volume:backup)
    source "$(dirname $0)/../data-volumes/vars"
    volume_info "$2"
    OUTPUT_FILE="$3"

    BACKUP_TMP_DIR=$(mktemp -d)
    BACKUP_TMP_FILE="$BACKUP_TMP_DIR/backup.tar"

    docker run --volumes-from="$VOLUME_CONTAINER" --rm=true -v $BACKUP_TMP_DIR:/backup "$VOLUME_IMAGE" tar -cf /backup/backup.tar app/
    
    pushd "$BACKUP_TMP_DIR" > /dev/null
    tar -xf backup.tar
    rm -rf backup.tar
    cp $VOLUME_PATHS .
    ls -1 "$VOLUME_CONFIG_DIR" > .app-links
    tar -cf backup.tar  --exclude=backup.tar .
    popd > /dev/null
    
    # if no file specified, output to stdout
    if [[ -z $OUTPUT_FILE ]]; then
      cat $BACKUP_TMP_FILE | base64 -w 0
    else
      mv $BACKUP_TMP_FILE $OUTPUT_FILE
    fi

    rm -rf $BACKUP_TMP_DIR
    
    ;;
    
  volume:restore)
    source "$(dirname $0)/../data-volumes/vars"
    volume_info "$2"

    BACKUP_TMP_DIR=$(mktemp -d)
    BACKUP_TMP_FILE="$BACKUP_TMP_DIR/backup.tar"
    OUTPUT_FILE="$3"

    pushd "$BACKUP_TMP_DIR" > /dev/null
    if [[ -z $OUTPUT_FILE ]]; then
      cat - | base64 -d > $BACKUP_TMP_FILE
    else
      echo "TODO"
    fi

    DOCKER_ARGS=()
    # Verify paths
    for path in $(tar xf $BACKUP_TMP_FILE ./.paths -O); do
      if [[ "$NAME" != "root" ]]; then
        ipath="${path//:/}"
        [[ "$path" != "$ipath" ]] && fail "$path: Path is forbidden"
      fi
      DOCKER_ARGS+=("-v" "$path")
    done

    # Create data container
    docker run --name "$VOLUME_CONTAINER" "${DOCKER_ARGS[@]}" -v $BACKUP_TMP_DIR:/backup "$VOLUME_IMAGE" tar -xvf /backup/backup.tar

    # Create data links
    mkdir -p "$VOLUME_CONFIG_DIR"

    echo "$(tar xf $BACKUP_TMP_FILE ./.paths -O)" > "$VOLUME_PATHS"
    
    echo "APP LINKS (shall be created manually)"
    for appLink in $(tar xf $BACKUP_TMP_FILE ./.app-links -O); do
      echo "dokku volume:link $appLink $2"
    done
    
    rm -Rf "$BACKUP_TMP_DIR"
    
    ;;

  nvcc:nginx.conf)

      cat "$DOKKU_ROOT/$APP/nginx.conf"

    ;;

  nvcc:nginx.conf.d)

      if [ -d "$DOKKU_ROOT/$APP/nginx.conf.d/" ] && [ "$(ls -A $DOKKU_ROOT/$APP/nginx.conf.d/)" ]; then
          ls -l "$DOKKU_ROOT/$APP/nginx.conf.d/"
      else
          echo "$DOKKU_ROOT/$APP/nginx.conf.d/ does not exist or is empty"
          exit 1
      fi

    ;;

  nvcc:nginx-vhosts-custom-configuration.conf)

      if [ -f "$DOKKU_ROOT/$APP/nginx.conf.d/nginx-vhosts-custom-configuration.conf" ]; then
          cat "$DOKKU_ROOT/$APP/nginx.conf.d/nginx-vhosts-custom-configuration.conf"
      else
          echo "$DOKKU_ROOT/$APP/nginx.conf.d/nginx-vhosts-custom-configuration.conf does not exist"
          exit 1
      fi

    ;;

  nvcc:port)

      cat "$DOKKU_ROOT/$APP/PORT"

    ;;

  help)
    cat && cat<<EOF
    nvcc:nginx.conf                             <app>                  display the current nginx.conf
    nvcc:nginx.conf.d                           <app>                  display the current nginx.conf.d/ directory contents
    nvcc:nginx-vhosts-custom-configuration.conf <app>                  will display the current nginx.conf.d/nginx-vhosts-custom-configuration.conf contents
    nvcc:port                                   <app>                  will display the current container port
EOF
    ;;
esac
