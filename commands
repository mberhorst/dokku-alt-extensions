#!/usr/bin/env bash
set -eo pipefail; [[ $DOKKU_TRACE ]] && set -x

# Check if name is specified
if [[ $1 == nvcc ]] || [[ $1 == nvcc:* ]]; then

  if [[ -z $2 ]]; then
    echo "You must specify an app name"
    exit 1
  else
    APP="$2"

    # Check if app exists with the same name
    if [ ! -d "$DOKKU_ROOT/$APP" ]; then
      echo "App $APP does not exist"
      exit 1
    fi

  fi
fi

case "$1" in

  # create a full backup to a target directory on the server; including:
  # - all metadata
  # - all volumes
  # - all LINKED MySQL and Postgres Databases
  #
  # WARNING: non-linked MySQL / Postgres DBs are NOT backed up!!!
  fullbackup)
    BACKUP_PATH="$2"
    if [[ "$BACKUP_PATH" == "" ]] ; then
      echo "Backup path not specified"
      exit 1
    fi

    echo "Backing up to $BACKUP_PATH"
    rm -rf "$BACKUP_PATH"
    mkdir -p "$BACKUP_PATH"

    # metadata (env vars etc)
    echo "- metadata"
    dokku backup:export "$BACKUP_PATH/metadata.tar"
    
    # volumes
    mkdir -p "$BACKUP_PATH/volumes"
    for volume in $(dokku volume:list); do
      echo "- volume $volume"
      dokku volume:backup $volume "$BACKUP_PATH/volumes/$volume.tar"
    done

    # databases
    mkdir -p "$BACKUP_PATH/databases"
    for app in $(dokku list); do
    
      # postgres
      for db in $(dokku postgresql:list $app); do
        echo "- app $app: postgresDB $db"
        mkdir -p "$BACKUP_PATH/databases/$app"
        mkdir -p "$BACKUP_PATH/databases/$app/postgresql/"
        dokku postgresql:dump $app $db > "$BACKUP_PATH/databases/$app/postgresql/$db.sql"
      done
      
      # mariadb (mysql)
      for db in $(dokku mariadb:list $app); do
        echo "- app $app: mariaDB $db"
        mkdir -p "$BACKUP_PATH/databases/$app"
        mkdir -p "$BACKUP_PATH/databases/$app/mariadb/"
        dokku mariadb:dump $app $db > "$BACKUP_PATH/databases/$app/mariadb/$db.sql"
      done
    done

    ;;

  # helper to backup a data volume; specifically everything inside "/app" (as *CONVENTION*)
  # So, if you create a volume using "volume:create notes_volume /app/var", it gets *backed up*.
  # If you create a volume using "volume:create notes_volume /var", it does NOT get *backed up*.
  # Furthermore, 2 special files are included in the backup:
  # .paths -- the paths with which the volume was created
  # .app-links -- the current connections to the apps
  #
  # HOW TO USE:
  # either: volume:backup | base64 -D > /your/local/backup.tar
  # or: volume:backup /path/on/server.tar
  volume:backup)
    source "$(dirname $0)/../data-volumes/vars"
    volume_info "$2"
    OUTPUT_FILE="$3"

    BACKUP_TMP_DIR=$(mktemp -d)
    BACKUP_TMP_FILE="$BACKUP_TMP_DIR/backup.tar"

    docker run --volumes-from="$VOLUME_CONTAINER" --rm=true -v $BACKUP_TMP_DIR:/backup "$VOLUME_IMAGE" tar -cf /backup/backup.tar app/
    
    pushd "$BACKUP_TMP_DIR" > /dev/null
    tar -xf backup.tar
    rm -rf backup.tar
    cp $VOLUME_PATHS .
    ls -1 "$VOLUME_CONFIG_DIR" > .app-links
    tar -cf backup.tar  --exclude=backup.tar .
    popd > /dev/null
    
    # if no file specified, output to stdout
    if [[ -z $OUTPUT_FILE ]]; then
      cat $BACKUP_TMP_FILE | base64 -w 0
    else
      mv $BACKUP_TMP_FILE $OUTPUT_FILE
    fi

    rm -rf $BACKUP_TMP_DIR
    
    ;;
    
  # helper to re-create a backed-up data volume
  # The following two usages are possible:
  # remote    : base64 -i bu.tar | ssh dokku@... volume:restore data-volume-name
  # local file:  ssh dokku@... volume:restore data-volume-name /your/path
  volume:restore)
    source "$(dirname $0)/../data-volumes/vars"
    volume_info "$2"

    BACKUP_TMP_DIR=$(mktemp -d)
    BACKUP_TMP_FILE="$BACKUP_TMP_DIR/backup.tar"
    INPUT_FILE="$3"

    pushd "$BACKUP_TMP_DIR" > /dev/null
    if [[ -z INPUT_FILE ]]; then
      cat - | base64 -d > $BACKUP_TMP_FILE
    else
      cp "$INPUT_FILE" "$BACKUP_TMP_FILE"
    fi

    # the following code is implemented like volume:create
    DOCKER_ARGS=()
    # Verify paths
    for path in $(tar xf $BACKUP_TMP_FILE ./.paths -O); do
      if [[ "$NAME" != "root" ]]; then
        ipath="${path//:/}"
        [[ "$path" != "$ipath" ]] && fail "$path: Path is forbidden"
      fi
      DOCKER_ARGS+=("-v" "$path")
    done

    # Create data container
    docker run --name "$VOLUME_CONTAINER" "${DOCKER_ARGS[@]}" -v $BACKUP_TMP_DIR:/backup "$VOLUME_IMAGE" tar -xvf /backup/backup.tar

    # Create data links
    mkdir -p "$VOLUME_CONFIG_DIR"

    echo "$(tar xf $BACKUP_TMP_FILE ./.paths -O)" > "$VOLUME_PATHS"
    
    echo "APP LINKS (shall be created manually)"
    for appLink in $(tar xf $BACKUP_TMP_FILE ./.app-links -O); do
      echo "dokku volume:link $appLink $2"
    done
    
    rm -Rf "$BACKUP_TMP_DIR"
    
    ;;

  nvcc:nginx.conf)

      cat "$DOKKU_ROOT/$APP/nginx.conf"

    ;;

  nvcc:nginx.conf.d)

      if [ -d "$DOKKU_ROOT/$APP/nginx.conf.d/" ] && [ "$(ls -A $DOKKU_ROOT/$APP/nginx.conf.d/)" ]; then
          ls -l "$DOKKU_ROOT/$APP/nginx.conf.d/"
      else
          echo "$DOKKU_ROOT/$APP/nginx.conf.d/ does not exist or is empty"
          exit 1
      fi

    ;;

  nvcc:nginx-vhosts-custom-configuration.conf)

      if [ -f "$DOKKU_ROOT/$APP/nginx.conf.d/nginx-vhosts-custom-configuration.conf" ]; then
          cat "$DOKKU_ROOT/$APP/nginx.conf.d/nginx-vhosts-custom-configuration.conf"
      else
          echo "$DOKKU_ROOT/$APP/nginx.conf.d/nginx-vhosts-custom-configuration.conf does not exist"
          exit 1
      fi

    ;;

  nvcc:port)

      cat "$DOKKU_ROOT/$APP/PORT"

    ;;

  help)
    cat && cat<<EOF
    nvcc:nginx.conf                             <app>                  display the current nginx.conf
    nvcc:nginx.conf.d                           <app>                  display the current nginx.conf.d/ directory contents
    nvcc:nginx-vhosts-custom-configuration.conf <app>                  will display the current nginx.conf.d/nginx-vhosts-custom-configuration.conf contents
    nvcc:port                                   <app>                  will display the current container port
    
    volume:backup <name> ⎢ base64 -D > /your/local/backup.tar
    volume:backup <name> /file/on/server.tar
    volume:restore -- remote usage: base64 -i backup.tar ⎢ ssh dokku@... volume:restore <name>
    volume:restore <name> /file/on/server.tar
  
    fullbackup /directory/on/server                                  do a full backup to the target directory on the server (metadata, volumes, linked MySQL and Postgres DBs)
EOF
    ;;
esac
